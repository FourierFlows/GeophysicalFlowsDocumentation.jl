var documenterSearchIndex = {"docs":
[{"location":"modules/barotropicqg/#BarotropicQG-Module-1","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"","category":"section"},{"location":"modules/barotropicqg/#Basic-Equations-1","page":"BarotropicQG Module","title":"Basic Equations","text":"","category":"section"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"This module solves the quasi-geostrophic barotropic vorticity equation on a beta-plane of variable fluid depth H-h(xy). The flow is obtained through a streamfunction psi as (u upsilon) = (-partial_ypsi partial_xpsi). All flow fields can be obtained from the quasi-geostrophic potential vorticity (QGPV). Here the QGPV is","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"underbracef_0 + beta y_textplanetary PV + underbrace(partial_x upsilon\n\t- partial_y u)_textrelative vorticity +\n\tunderbracefracf_0 hH_texttopographic PV","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"The dynamical variable is the component of the vorticity of the flow normal to the plane of motion, zetaequiv partial_x upsilon- partial_y u = nabla^2psi. Also, we denote the topographic PV with etaequiv f_0 hH. Thus, the equation solved by the module is:","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"partial_t zeta + mathsfJ(psi underbracezeta + eta_equiv q) +\nbetapartial_xpsi = underbrace-leftmu + nu(-1)^n_nu nabla^2n_nu\nright zeta _textrmdissipation + f ","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"where mathsfJ(a b) = (partial_x a)(partial_y b)-(partial_y a)(partial_x b). On the right hand side, f(xyt) is forcing, mu is linear drag, and nu is hyperviscosity. Plain old viscosity corresponds to n_nu=1. The sum of relative vorticity and topographic PV is denoted with qequivzeta+eta.","category":"page"},{"location":"modules/barotropicqg/#Implementation-1","page":"BarotropicQG Module","title":"Implementation","text":"","category":"section"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"The equation is time-stepped forward in Fourier space:","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"partial_t widehatzeta = - widehatmathsfJ(psi q) +betafracmathrmik_xk^2widehatzeta -left(mu\n+nu k^2n_nuright) widehatzeta  + widehatf ","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"In doing so the Jacobian is computed in the conservative form: mathsfJ(fg) = partial_y  (partial_x f) g -partial_x (partial_y f) g.","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"Thus:","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"mathcalL = betafracmathrmik_xk^2 - mu - nu k^2n_nu ","category":"page"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"mathcalN(widehatzeta) = - mathrmik_x mathrmFFT(u q)-\n\tmathrmik_y mathrmFFT(upsilon q) ","category":"page"},{"location":"modules/barotropicqg/#Examples-1","page":"BarotropicQG Module","title":"Examples","text":"","category":"section"},{"location":"modules/barotropicqg/#","page":"BarotropicQG Module","title":"BarotropicQG Module","text":"examples/barotropicqg_betadecay.jl: A script that simulates decaying quasi-geostrophic flow on a beta-plane demonstrating zonation.\nexamples/barotropicqg_betaforced.jl: A script that simulates forced-dissipative quasi-geostrophic flow on a beta-plane demonstrating zonation. The forcing is temporally delta-correlated and its spatial structure is isotropic with power in a narrow annulus of total radius kf in wavenumber space.\nexamples/barotropicqg_acc.jl: A script that simulates barotropic quasi-geostrophic flow above topography reproducing the results of the paper by\nConstantinou, N. C. (2018). A barotropic model of eddy saturation. J. Phys. Oceanogr., 48 (2), 397-411.","category":"page"},{"location":"modules/barotropicqgql/#BarotropicQGQL-Module-1","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"","category":"section"},{"location":"modules/barotropicqgql/#Basic-Equations-1","page":"BarotropicQGQL Module","title":"Basic Equations","text":"","category":"section"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"This module solves the quasi-linear quasi-geostrophic barotropic vorticity equation on a beta-plane of variable fluid depth H-h(xy).  Quasi-linear refers to the dynamics that neglect the eddy–eddy interactions in the eddy evolution equation after an eddy–mean flow decomposition, e.g., ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"phi(x y t) = overlinephi(y t) + phi(xyt) ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"where overline above denotes a zonal mean, overlinephi(y t) = int phi(x y t)mathrmdxL_x, and prime denotes deviations from the zonal mean. This approximation is used in many process-model studies of zonation, e.g., ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"Farrell, B. F. and Ioannou, P. J. (2003). Structural stability of turbulent jets. J. Atmos. Sci., 60, 2101-2118.\nSrinivasan, K. and Young, W. R. (2012). Zonostrophic instability. J. Atmos. Sci., 69 (5), 1633-1656.\nConstantinou, N. C., Farrell, B. F., and Ioannou, P. J. (2014). Emergence and equilibration of jets in beta-plane turbulence: applications of Stochastic Structural Stability Theory. J. Atmos. Sci., 71 (5), 1818-1842.","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"As in the BarotropicQG module, the flow is obtained through a streamfunction psi as (u upsilon) = (-partial_ypsi partial_xpsi). All flow fields can be obtained from the quasi-geostrophic potential vorticity (QGPV). Here the QGPV is","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"underbracef_0 + beta y_textplanetary PV + underbrace(partial_x upsilon\n\t- partial_y u)_textrelative vorticity +\n\tunderbracefracf_0 hH_texttopographic PV","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"The dynamical variable is the component of the vorticity of the flow normal to the plane of motion, zetaequiv partial_x upsilon- partial_y u = nabla^2psi. Also, we denote the topographic PV with etaequiv f_0 hH. After we apply the eddy-mean flow decomposition above, the QGPV dynamics are:","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"partial_t overlinezeta + mathsfJ(overlinepsi underbraceoverlinezeta + overlineeta_equiv overlineq) + overlinemathsfJ(psi underbracezeta + eta_equiv q) = underbrace-leftmu + nu(-1)^n_nu nabla^2n_nu\nright overlinezeta _textrmdissipation  ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"partial_t zeta + mathsfJ(psi overlineq) + mathsfJ(overlinepsi q) + underbracemathsfJ(psi q) - overlinemathsfJ(psi q)_textrmEENL + \nbetapartial_xpsi = underbrace-leftmu + nu(-1)^n_nu nabla^2n_nu\nright zeta_textrmdissipation + f ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"where mathsfJ(a b) = (partial_x a)(partial_y b)-(partial_y a)(partial_x b). On the right hand side, f(xyt) is forcing (which is assumed to have zero mean, overlinef=0), mu is linear drag, and nu is hyperviscosity. Plain old viscosity corresponds to n_nu=1. The sum of relative vorticity and topographic PV is denoted with qequivzeta+eta.","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"Quasi-linear dynamics neglect the term eddy-eddy nonlinearity (EENL) term above.","category":"page"},{"location":"modules/barotropicqgql/#Implementation-1","page":"BarotropicQGQL Module","title":"Implementation","text":"","category":"section"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"The equation is time-stepped forward in Fourier space:","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"partial_t widehatzeta = - widehatmathsfJ(psi q)^textrmQL +betafracmathrmik_xk^2widehatzeta -left(mu\n+nu k^2n_nuright) widehatzeta  + widehatf ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"In doing so the Jacobian is computed in the conservative form: mathsfJ(fg) = partial_y  (partial_x f) g -partial_x (partial_y f) g. The superscript QL in the Jacobian term above denotes that remove triad interactions that correspond to the EENL term.","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"Thus:","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"mathcalL = betafracmathrmik_xk^2 - mu - nu k^2n_nu ","category":"page"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"mathcalN(widehatzeta) = - mathrmik_x mathrmFFT(u q)^textrmQL-\n\tmathrmik_y mathrmFFT(upsilon q)^textrmQL ","category":"page"},{"location":"modules/barotropicqgql/#Examples-1","page":"BarotropicQGQL Module","title":"Examples","text":"","category":"section"},{"location":"modules/barotropicqgql/#","page":"BarotropicQGQL Module","title":"BarotropicQGQL Module","text":"examples/barotropicqgql_betaforced.jl: A script that simulates forced-dissipative quasi-linear quasi-geostrophic flow on a beta-plane demonstrating zonation. The forcing is temporally delta-correlated and its spatial structure is isotropic with power in a narrow annulus of total radius kf in wavenumber space. This example demonstrates that the anisotropic inverse energy cascade is not required for zonation.","category":"page"},{"location":"modules/multilayerqg/#MultilayerQG-Module-1","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"","category":"section"},{"location":"modules/multilayerqg/#Basic-Equations-1","page":"MultilayerQG Module","title":"Basic Equations","text":"","category":"section"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"This module solves the layered quasi-geostrophic equations on a beta-plane of variable fluid depth H-h(xy). The flow in each layer is obtained through a streamfunction psi_j as (u_j upsilon_j) = (-partial_ypsi_j partial_xpsi_j), j=1n, where n is the number of fluid layers.","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"The QGPV in each layer is","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"mathrmQGPV_j = q_j  + underbracef_0+beta y_textrmplanetary PV + delta_jnunderbracefracf_0 hH_n_textrmtopographic PVquad j=1n","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"where","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"q_1 = nabla^2psi_1 + F_32 1 (psi_2-psi_1)\nq_j = nabla^2psi_j + F_j-12 j (psi_j-1-psi_j) + F_j+12 j (psi_j+1-psi_j)quad j=2dotsn-1\nq_n = nabla^2psi_n + F_n-12 n (psi_n-1-psi_n)","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"with","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"F_j+12 k = fracf_0^2g_j+12 H_kquadtextandquad\ng_j+12 = gfracrho_j+1-rho_jrho_j+1 ","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"Therefore, in Fourier space the q's and psi's are related through","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"beginpmatrix widehatq_boldsymbolk1vdotswidehatq_boldsymbolkn endpmatrix =\nunderbraceleft(-boldsymbolk^2mathbb1 + mathbbF right)_equiv mathbbS_boldsymbolk\nbeginpmatrix widehatpsi_boldsymbolk1vdotswidehatpsi_boldsymbolkn endpmatrix","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"where","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"mathbbF equiv beginpmatrix\n -F_32 1               F_32 1     0     cdots     0\n  F_32 2  -(F_32 2+F_52 2)  F_52 2         vdots\n 0                             ddots     ddots    ddots  \n vdots                                                      0 \n 0                  cdots                0    F_n-12 n  -F_n-12 n\nendpmatrix","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"Including an imposed zonal flow U_j(y) in each layer the equations of motion are:","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"partial_t q_j + mathsfJ(psi_j q_j ) + (U_j - partial_ypsi_j) partial_x Q_j +  U_j partial_x q_j  + (partial_y Q_j)(partial_xpsi_j) = -delta_jnmunabla^2psi_n - nu(-1)^n_nu nabla^2n_nu q_j","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"with","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"partial_y Q_j equiv beta - partial_y^2 U_j - (1-delta_j1)F_j-12 j (U_j-1-U_j) - (1-delta_jn)F_j+12 j (U_j+1-U_j) + delta_jnpartial_yeta \npartial_x Q_j equiv delta_jnpartial_xeta","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"The eddy kinetic energy in each layer is:","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"textrmKE_j = dfracH_jH int dfrac12 boldsymbolnablapsi_j^2 fracmathrmd^2boldsymbolxL_x L_yquad j=1dotsn","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"while the eddy potential energy related to each of fluid interface is","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"textrmPE_j+12 = int dfrac12 dfracf_0^2g_j+12 (psi_j-psi_j+1)^2 fracmathrmd^2boldsymbolxL_x L_yquad j=1dotsn-1","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"The lateral eddy fluxes in each layer are:","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"textrmlateralfluxes_j = dfracH_jH int dfrac12 U_jupsilon_j partial_y u_j fracmathrmd^2boldsymbolxL_x L_yquad j=1dotsn","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"while the vertical fluxes accros fluid interfaces are:","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"textrmverticalfluxes_j+12 = int dfracf_0^2g_j+12 H (U_j-U_j+1)upsilon_j+1psi_j fracmathrmd^2boldsymbolxL_x L_yquad j=1dotsn-1\n","category":"page"},{"location":"modules/multilayerqg/#Implementation-1","page":"MultilayerQG Module","title":"Implementation","text":"","category":"section"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"Matrices mathbbS_boldsymbolk as well as mathbbS^-1_boldsymbolk are included in params as params.S and params.invS respectively.","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"You can get widehatpsi_j from widehatq_j with streamfunctionfrompv!(psih, qh, invS, grid), while to go from widehatpsi_j back to widehatq_j pvfromstreamfunction!(qh, psih, S, grid).","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"The equations are time-stepped forward in Fourier space:","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"partial_t widehatq_j = - widehatmathsfJ(psi_j q_j)  - widehatU_j partial_x Q_j - widehatU_j partial_x q_j\n+ widehat(partial_ypsi_j) partial_x Q_j  - widehat(partial_xpsi_j)(partial_y Q_j) + delta_jnmu k^2 widehatpsi_n - nu k^2n_nu widehatq_j","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"In doing so the Jacobian is computed in the conservative form: mathsfJ(fg) = partial_y  (partial_x f) g -partial_x (partial_y f) g.","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"Thus:","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"mathcalL = - nu k^2n_nu ","category":"page"},{"location":"modules/multilayerqg/#","page":"MultilayerQG Module","title":"MultilayerQG Module","text":"mathcalN(widehatq_j) = - widehatmathsfJ(psi_j q_j) - widehatU_j partial_x Q_j - widehatU_j partial_x q_j\n + widehat(partial_ypsi_j)(partial_x Q_j) - widehat(partial_xpsi_j)(partial_y Q_j) + delta_jnmu k^2 widehatpsi_n ","category":"page"},{"location":"modules/twodturb/#TwoDTurb-Module-1","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"","category":"section"},{"location":"modules/twodturb/#Basic-Equations-1","page":"TwoDTurb Module","title":"Basic Equations","text":"","category":"section"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"This module solves two-dimensional incompressible turbulence. The flow is given through a streamfunction psi as (uupsilon) = (-partial_ypsi partial_xpsi). The dynamical variable used here is the component of the vorticity of the flow normal to the plane of motion, zeta=partial_x upsilon- partial_y u = nabla^2psi. The equation solved by the module is:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"partial_t zeta + mathsfJ(psi zeta) = underbrace-leftmu(-1)^n_mu nabla^2n_mu\n+nu(-1)^n_nu nabla^2n_nuright zeta_textrmdissipation + f ","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"where mathsfJ(a b) = (partial_x a)(partial_y b)-(partial_y a)(partial_x b). On the right hand side, f(xyt) is forcing, mu is hypoviscosity, and nu is hyperviscosity. Plain old linear drag corresponds to n_mu=0, while normal viscosity corresponds to n_nu=1.","category":"page"},{"location":"modules/twodturb/#Implementation-1","page":"TwoDTurb Module","title":"Implementation","text":"","category":"section"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"The equation is time-stepped forward in Fourier space:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"partial_t widehatzeta = - widehatmathsfJ(psi zeta) -left(mu k^2n_mu\n+nu k^2n_nuright) widehatzeta  + widehatf ","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"In doing so the Jacobian is computed in the conservative form: mathsfJ(ab) = partial_y  (partial_x a) b -partial_x (partial_y a) b.","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"Thus:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"mathcalL = -mu k^-2n_mu - nu k^2n_nu ","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"mathcalN(widehatzeta) = - mathrmik_x mathrmFFT(u zeta)-\n\tmathrmik_y mathrmFFT(upsilon zeta) + widehatf ","category":"page"},{"location":"modules/twodturb/#AbstractTypes-and-Functions-1","page":"TwoDTurb Module","title":"AbstractTypes and Functions","text":"","category":"section"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"Params","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"For the unforced case (f=0) parameters AbstractType is build with Params and it includes:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"ν:   Float; viscosity or hyperviscosity coefficient.\nnν: Integer0; the order of viscosity n_nu. Case n_nu=1 gives normal viscosity.\nμ: Float; bottom drag or hypoviscosity coefficient.\nnμ: Integerge 0; the order of hypodrag n_mu. Case n_mu=0 gives plain linear drag mu.","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"For the forced case (fne 0) parameters AbstractType is build with ForcedParams. It includes all parameters in Params and additionally:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"calcF!: Function that calculates the forcing widehatf","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"Vars","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"For the unforced case (f=0) variables AbstractType is build with Vars and it includes:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"zeta: Array of Floats; relative vorticity.\nu: Array of Floats; x-velocity, u.\nv: Array of Floats; y-velocity, upsilon.\nsol: Array of Complex; the solution, widehatzeta.\nzetah: Array of Complex; the Fourier transform widehatzeta.\nuh: Array of Complex; the Fourier transform widehatu.\nvh: Array of Complex; the Fourier transform widehatupsilon.","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"For the forced case (fne 0) variables AbstractType is build with ForcedVars. It includes all variables in Vars and additionally:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"Fh: Array of Complex; the Fourier transform widehatf.\nprevsol: Array of Complex; the values of the solution sol at the previous time-step (useful for calculating the work done by the forcing).","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"calcN! function","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"The nonlinear term mathcalN(widehatzeta) is computed via functions:","category":"page"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"calcN_advection!: computes - widehatmathsfJ(psi zeta) and stores it in array N.\ncalcN_forced!: computes - widehatmathsfJ(psi zeta) via calcN_advection! and then adds to it the forcing widehatf computed via calcF! function. Also saves the solution widehatzeta of the previous time-step in array prevsol.\nupdatevars!: uses sol to compute zeta, u, upsilon, widehatu, and widehatupsilon and stores them into corresponding arrays of Vars/ForcedVars.","category":"page"},{"location":"modules/twodturb/#Examples-1","page":"TwoDTurb Module","title":"Examples","text":"","category":"section"},{"location":"modules/twodturb/#","page":"TwoDTurb Module","title":"TwoDTurb Module","text":"examples/twodturb_mcwilliams1984.jl: A script that simulates decaying two-dimensional turbulence reproducing the results of the paper by\nMcWilliams, J. C. (1984). The emergence of isolated coherent vortices in turbulent flow. J. Fluid Mech., 146, 21-43.\nexamples/twodturb_randomdecay.jl: A script that simulates decaying two-dimensional turbulence starting from random initial conditions.\nexamples/twodturb_stochasticforcing.jl: A script that simulates forced-dissipative two-dimensional turbulence with isotropic temporally delta-correlated stochastic forcing.","category":"page"},{"location":"basics/#Code-Basics-1","page":"Code Basics","title":"Code Basics","text":"","category":"section"},{"location":"basics/#Basic-Notation-1","page":"Code Basics","title":"Basic Notation","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The code solves partial differential equations of the general form:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"partial_t u = mathcalLu + mathcalN(u) ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"(Note: ODEs are special cases of the above. Thus the code also solves ODEs.)","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"We decompose the right hand side of the above in a linear part (mathcalLu) and a nonlinear part (mathcalN(u)). The time steppers treat the linear and nonlinear parts differently.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Boundary conditions in all spatial dimensions are periodic. That allows us to expand all variables using a Fourier decomposition. For example, a variable phi(x t) that depends in one spatial dimension is expanded as:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"phi(x t) = sum_k widehatphi(k t)e^mathrmi k x ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"where wavenumbers k take the values tfrac2piL_x0pm 1pm 2dots. The equation is time-stepped forward in Fourier space. That way u becomes the array with all Fourier coefficients of the solution.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The coefficients for the linear operator mathcalL are stored in an array called LC. The term mathcalN(u) is computed for by calling the function calcN!.","category":"page"},{"location":"basics/#Abstract-SuperTypes-1","page":"Code Basics","title":"Abstract SuperTypes","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The code is divided along conceptual lines into problem-agnostic and problem-specific components. Files that contain problem-agnostic parts of the code are stored in /src. Files in /src define the domain, 'AbstractTypes' that supertype problem-specific types, and time-stepper types and routines. Problem-specific modules are stored in /src/physics.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Below is a list of all Abstract Supertypes used by the code:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"AbstractGrid: Includes all variables that have to do with the grid, both in physical space as well as in wavenumber space. Currently implemented are: ZeroGrid for ODEs, OneGrid for PDEs with one spatial dimension, and TwoGrid for PDEs with two spatial dimensions. Grids are generic and work for any problem of that particular dimension.\nAbstractParams: Includes all parameters or functions related with the problem do not vary throughout the integration.\nAbstractVars: Includes all variables of the problem that change along the integration.\nAbstractEquation: Includes the array with the coefficients of the linear part of the equation, LC as well as function calcN! that computes the nonlinear part of the equation.\nAbstractState: Includes the solution sol at current time-step as well as the time-step dt, the time t, and step which counts the number of time-steps taken.\nAbstractTimeStepper: Includes all details for the time-stepper (e.g., dt, various coefficients, sol at intermediate time-step values). Time-steppers are generic and work for any problem.\nAbstractProblem: A super-supertype that includes all of the above. That is problem includes grid, vars, params, eqn, ts, state, and also t and step.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Grids and time-steppers are generic and work for any problem of that particular dimension. State and Problem just gathers things together. Thus, to write a solver for a new physical problem you only need to prescribe params, vars, the coefficients of the linear part, LC, and function calcN!.","category":"page"},{"location":"basics/#Source-code-organization-1","page":"Code Basics","title":"Source code organization","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The code is divided along conceptual lines into problem-agnostic and problem-specific components. Files that contain problem-agnostic parts of the code are stored in /src. Files in /src define the domain, 'AbstractTypes' that supertype problem-specific types, and time-stepper types and routines. Problem-specific modules are stores in /src/physics.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Here's an overview of the code structure:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"/src/\nFourierFlows.jl\nDefines supertyping AbstractParams, AbstractGrid, etc.\nDefines a Problem type to organize the grid, vars, params, equation, and timestepper into a single structure.\nIncludes all sources files and physics files.\ntimesteppers.jl: defines modules and stepforward! routines for   various time-steppers. Current implemented time-steppers are:\nForward Euler\n3rd-order Adams-Bashforth (AB3)\n4th-order Runge-Kutta (RK4)\n4th-order Runge-Kutta Exponential Time Differencing (ETDRK4)\n4th-order Dual Runge-Kutta (DualRK4)\n4th-order Dual Runge-Kutta Exponential Time Differencing (DualETDRK4)\nFor each time-stepper exists also a \"filtered\" version that filters out high-wavenumber spectral components of the solution. The Dual time-steppers evolve a state variable that comprises both of real valued         and complex valued fields.\nphysics/\ntwodturb.jl: Defines a TwoDTurb module that provides a solver for the two-dimensional vorticity equation.\nbarotropicqg.jl: Defines a BarotropicQG module that provides several solvers for the barotropic QG model that permit beta, topography, beta + topography, and forcing.\nkuramotosivashinsky.jl: Defines a KuramotoSivashinsky module that solves the Kuramoto-Sivashinsky.\nverticallyfourierboussinesq.jl: Defines a VerticallyFourierBoussinesq module that solves the two-mode truncation of the Fourier series thin-layer approximation to the hydrostatic Boussinesq equations.\nverticallycosinerboussinesq.jl: Defines a VerticallyCosineBoussinesq module that solves the two-mode truncation of the Sin/Cos series thin-layer approximation to the hydrostatic Boussinesq equations.\ntraceradvdiff.jl: Defines a TracerAdvDiff module that provides a solver for a two-dimensional and periodic tracer field in a given 2D flow (u, w), which can be an arbitrary function of x, z, and t.","category":"page"},{"location":"basics/#Basic-steps-for-solving-a-problem:-step-through-an-example-script-1","page":"Code Basics","title":"Basic steps for solving a problem: step through an example script","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"To illustrate the basic steps for solving a problem consider the 1D Kuramoto-Sivashinsky equation for u(x t):","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"partial_t u + partial_x^4 u + partial_x^2 u + upartial_x u = 0 ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"which in Fourier base reads:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"partial_t widehatu = underbrace(- k_x^4 + k_x^2) widehatu_mathcalLwidehatu\n+ underbracewidehat -upartial_x u _mathcalN(widehatu) ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The steps to construct an AbstractProblem for the above are:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Construct an AbstractGrid; for this problem we use the OneGrid.\nConstruct an AbstractParams; for this problem params is be empty as there are no parameters in the equation. (Note that e.g., the domain size Lx and the number of gridpoints nx belong to the grid.)\nConstruct an AbstractVars; for this problem vars includes u, partial_x u, upartial_x u and their Fourier transforms widehatu, widehatpartial_x u, widehatupartial_xu.\nConstruct the equations by prescribing coefficients for the linear part as an array LC and a function calcN! that computes mathcalN(widehatu).\nConstruct the time-stepper which includes function stepforward! that time-steps the solution.\nConstruct the state and gather everything as an AbstractProblem.","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The example script found in  examples/kuramotosivashinsky/trefethenexample.jl demonstrates the above steps needed to construct an AbstractProblem. The prob is constructed by calling prob = InitialValueProblem(nx=nx, Lx=Lx, dt=dt, stepper=\"ETDRK4\"). Looking into the  InitialValueProblem function we can see the above steps:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"function InitialValueProblem(;\n     nx = 256,\n     Lx = 2π,\n     dt = 0.01,\nstepper = \"RK4\"\n)\n\ng  = OneDGrid(nx, Lx)\npr = Params()\nvs = Vars(g)\neq = Equation(pr, g)\nts = FourierFlows.autoconstructtimestepper(stepper, dt, eq.LC, g)\n\nFourierFlows.Problem(g, vs, pr, eq, ts)\nend","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The OneDGrid function is called for the grid. Within grid the wavenumber array is constructed:","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"i1 = 0:Int(nx/2)\ni2 = Int(-nx/2+1):-1\nk = Array{T}(2π/Lx*cat(1, i1, i2))\nkr = Array{T}(2π/Lx*cat(1, i1))","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"For real-valued fields we use rfft and thus only positive wavenumbers are involved: array kr. E.g., for nx=8 and Lx=2π the wavenumber grids are: k = [0, 1, 2, 3, 4, -3, -2, -1] and kr = [0, 1, 2, 3, 4].","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The construction of the grids only works for even number of grid points. Moreover, since the code relies on the mathrmFFT algorithm, we suggest you use a power of 2 as the number of grid points, since then mathrmFFT is most efficient. ","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Function Vars(g) initialize variables u, ux, and uux as real valued arrays of length nx and variables uh, uxh, and uuxh as complex valued arrays of length nkr = Int(nx/2+1) (the same length as kr). As a general convention variable names with h denote the Fourier transforms of the corresponding variable (h stands for 'hat').","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The array LC is constructed by Equation function","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"function Equation(p, g)\n  LC = @. g.kr^2 - g.kr^4\n  FourierFlows.Equation(LC, calcN!)\nend","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Also eq includes function calcN! which computes the nonlinear term mathcalN(widehatu):","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"function calcN!(N, sol, t, s, v, p, g)\n  @. v.uh = sol\n  @. v.uxh = im*g.kr*sol\n  A_mul_B!(v.u, g.irfftplan, v.uh)\n  A_mul_B!(v.ux, g.irfftplan, v.uxh)\n  @. v.uux = v.u*v.ux\n  A_mul_B!(v.uuxh, g.rfftplan, v.uux)\n  @. N = -v.uuxh\n  dealias!(N, g)\n  nothing\nend","category":"page"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"The time-stepper is constructed and stored as ts. Finally, all supertypes are gathered together as an AbstractProblem.","category":"page"},{"location":"basics/#Tutorials-1","page":"Code Basics","title":"Tutorials","text":"","category":"section"},{"location":"basics/#","page":"Code Basics","title":"Code Basics","text":"Pages = [\n    \"modules/kuramotosivashinsky.md\",\n    \"modules/twodturb.md\",\n    \"modules/barotropicqg.md\",\n    \"modules/traceradvdiff.md\"\n        ]\nDepth = 1","category":"page"},{"location":"#GeophysicalFlows.jl-Documentation-1","page":"Home","title":"GeophysicalFlows.jl Documentation","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"GeophysicalFlows.jl is a collection of modules which leverage the  FourierFlows.jl framework to provide solvers for problems in Geophysical Fluid Dynamics, on periodic domains and using Fourier-based pseudospectral methods.","category":"page"},{"location":"#Developers-1","page":"Home","title":"Developers","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"FourierFlows is currently being developed by Navid C. Constantinou and Gregory L. Wagner.","category":"page"},{"location":"#Cite-1","page":"Home","title":"Cite","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The code is citable via zenodo.","category":"page"},{"location":"man/types/#Private-types-1","page":"Private types","title":"Private types","text":"","category":"section"},{"location":"man/types/#Private-types-in-module-GeophysicalFlows:-1","page":"Private types","title":"Private types in module GeophysicalFlows:","text":"","category":"section"},{"location":"man/types/#","page":"Private types","title":"Private types","text":"Modules = [GeophysicalFlows]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"man/types/#Private-types-in-module-TwoDTurb:-1","page":"Private types","title":"Private types in module TwoDTurb:","text":"","category":"section"},{"location":"man/types/#","page":"Private types","title":"Private types","text":"Modules = [GeophysicalFlows.TwoDTurb]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"man/types/#GeophysicalFlows.TwoDTurb.ForcedVars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,FourierFlows.AbstractGrid{T,Ta} where Ta}} where T where Dev","page":"Private types","title":"GeophysicalFlows.TwoDTurb.ForcedVars","text":"ForcedVars(dev, g)\n\nReturns the vars for forced two-dimensional turbulence on device dev and with  grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/types/#GeophysicalFlows.TwoDTurb.Params","page":"Private types","title":"GeophysicalFlows.TwoDTurb.Params","text":"Params(ν, nν, μ, nμ, calcF!)\n\nReturns the params for two-dimensional turbulence.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#GeophysicalFlows.TwoDTurb.StochasticForcedVars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,FourierFlows.AbstractGrid{T,Ta} where Ta}} where T where Dev","page":"Private types","title":"GeophysicalFlows.TwoDTurb.StochasticForcedVars","text":"StochasticForcedVars(dev, g)\n\nReturns the vars for stochastically forced two-dimensional turbulence on device dev and with grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/types/#GeophysicalFlows.TwoDTurb.Vars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,FourierFlows.AbstractGrid{T,Ta} where Ta}} where T where Dev","page":"Private types","title":"GeophysicalFlows.TwoDTurb.Vars","text":"Vars(dev, g)\n\nReturns the vars for unforced two-dimensional turbulence on device dev and with  grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/types/#Private-types-in-module-BarotropicQG:-1","page":"Private types","title":"Private types in module BarotropicQG:","text":"","category":"section"},{"location":"man/types/#","page":"Private types","title":"Private types","text":"Modules = [GeophysicalFlows.BarotropicQG]\nPublic = false\nOrder = [:type]","category":"page"},{"location":"man/types/#GeophysicalFlows.BarotropicQG.ForcedVars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,FourierFlows.AbstractGrid{T,Ta} where Ta}} where T where Dev","page":"Private types","title":"GeophysicalFlows.BarotropicQG.ForcedVars","text":"ForcedVars(dev, g)\n\nReturns the vars for forced two-dimensional barotropic QG problem on device dev and with grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/types/#GeophysicalFlows.BarotropicQG.Params","page":"Private types","title":"GeophysicalFlows.BarotropicQG.Params","text":"Params(g::TwoDGrid, f0, β, FU, eta, μ, ν, nν, calcFU, calcFq)\n\nReturns the params for an unforced two-dimensional barotropic QG problem.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#GeophysicalFlows.BarotropicQG.Params-Union{Tuple{A}, Tuple{T}, Tuple{FourierFlows.AbstractGrid{T,A},Any,Any,Function,Any,Any,Int64,Any,Any}} where A where T","page":"Private types","title":"GeophysicalFlows.BarotropicQG.Params","text":"Params(g::TwoDGrid, f0, β, eta::Function, μ, ν, nν, calcFU, calcFq)\n\nConstructor for Params that accepts a generating function for the topographic PV.\n\n\n\n\n\n","category":"method"},{"location":"man/types/#GeophysicalFlows.BarotropicQG.StochasticForcedVars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,FourierFlows.AbstractGrid{T,Ta} where Ta}} where T where Dev","page":"Private types","title":"GeophysicalFlows.BarotropicQG.StochasticForcedVars","text":"StochasticForcedVars(dev, g)\n\nReturns the vars for stochastically forced two-dimensional barotropic QG problem on device dev and with grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/types/#GeophysicalFlows.BarotropicQG.Vars-Union{Tuple{T}, Tuple{Dev}, Tuple{Dev,FourierFlows.AbstractGrid{T,Ta} where Ta}} where T where Dev","page":"Private types","title":"GeophysicalFlows.BarotropicQG.Vars","text":"Vars(dev, g)\n\nReturns the vars for unforced two-dimensional barotropic QG problem on device dev and with grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions/#Functions-exported-from-GeophysicalFlows:-1","page":"Functions","title":"Functions exported from GeophysicalFlows:","text":"","category":"section"},{"location":"man/functions/#","page":"Functions","title":"Functions","text":"Modules = [GeophysicalFlows]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/functions/#Functions-exported-from-TwoDTurb:-1","page":"Functions","title":"Functions exported from TwoDTurb:","text":"","category":"section"},{"location":"man/functions/#","page":"Functions","title":"Functions","text":"Modules = [GeophysicalFlows.TwoDTurb]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.Problem-Tuple{}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.Problem","text":"Problem(; parameters...)\n\nConstruct a 2D turbulence problem.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.dissipation-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.dissipation","text":"dissipation(prob)\n\nReturns the domain-averaged dissipation rate. nν must be >= 1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.drag-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.drag","text":"drag(prob)\n\nReturns the extraction of domain-averaged energy by drag/hypodrag μ.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.energy-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.energy","text":"energy(prob)\n\nReturns the domain-averaged kinetic energy in the Fourier-transformed vorticity solution sol.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.enstrophy-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.enstrophy","text":"enstrophy(prob)\n\nReturns the domain-averaged enstrophy in the Fourier-transformed vorticity solution sol.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.set_zeta!-Tuple{Any,Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.set_zeta!","text":"set_zeta!(prob, zeta)\n\nSet the solution sol as the transform of zeta and update variables v on the grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.updatevars!-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.updatevars!","text":"updatevars!(prob)\n\nUpdate the vars in v on the grid g with the solution in sol.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.TwoDTurb.work-Tuple{Any,GeophysicalFlows.TwoDTurb.Vars{#s28,#s27,#s26,Nothing} where #s26<:AbstractArray where #s27<:AbstractArray where #s28<:AbstractArray,Any}","page":"Functions","title":"GeophysicalFlows.TwoDTurb.work","text":"work(prob)\nwork(sol, v, g)\n\nReturns the domain-averaged rate of work of energy by the forcing Fh.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#Functions-exported-from-BarotropicQG:-1","page":"Functions","title":"Functions exported from BarotropicQG:","text":"","category":"section"},{"location":"man/functions/#","page":"Functions","title":"Functions","text":"Modules = [GeophysicalFlows.BarotropicQG]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.dissipation-NTuple{4,Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.dissipation","text":"dissipation(prob)\ndissipation(s, v, p, g)\n\nReturns the domain-averaged dissipation rate. nν must be >= 1.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.drag-NTuple{4,Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.drag","text":"drag(prob)\ndrag(s, v, p, g)\n\nReturns the extraction of domain-averaged energy by drag μ.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.energy-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.energy","text":"Calculate the domain-averaged kinetic energy.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.enstrophy-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.enstrophy","text":"Returns the domain-averaged enstrophy.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.meanenergy-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.meanenergy","text":"Returns the energy of the domain-averaged U.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.meanenstrophy-Tuple{Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.meanenstrophy","text":"Returns the enstrophy of the domain-averaged U.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.set_zeta!-Tuple{Any,GeophysicalFlows.BarotropicQG.Vars,Any,Any,Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.set_zeta!","text":"set_zeta!(prob, zeta)\nset_zeta!(s, v, g, zeta)\n\nSet the solution sol as the transform of zeta and update variables v on the grid g.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.updatevars!-NTuple{4,Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.updatevars!","text":"updatevars!(v, s, g)\n\nUpdate the vars in v on the grid g with the solution in sol.\n\n\n\n\n\n","category":"method"},{"location":"man/functions/#GeophysicalFlows.BarotropicQG.work-Tuple{Any,GeophysicalFlows.BarotropicQG.Vars{#s35,#s34,#s33,#s32,Nothing} where #s32<:AbstractArray where #s33<:AbstractArray where #s34<:AbstractArray where #s35<:AbstractArray,Any}","page":"Functions","title":"GeophysicalFlows.BarotropicQG.work","text":"work(prob)\nwork(s, v, p, g)\n\nReturns the domain-averaged rate of work of energy by the forcing Fqh.\n\n\n\n\n\n","category":"method"}]
}
