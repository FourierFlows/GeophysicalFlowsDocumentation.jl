<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2D forced-dissipative turbulence budgets · GeophysicalFlows.jl</title><meta name="title" content="2D forced-dissipative turbulence budgets · GeophysicalFlows.jl"/><meta property="og:title" content="2D forced-dissipative turbulence budgets · GeophysicalFlows.jl"/><meta property="twitter:title" content="2D forced-dissipative turbulence budgets · GeophysicalFlows.jl"/><meta name="description" content="Documentation for GeophysicalFlows.jl."/><meta property="og:description" content="Documentation for GeophysicalFlows.jl."/><meta property="twitter:description" content="Documentation for GeophysicalFlows.jl."/><meta property="og:url" content="https://fourierflows.github.io/GeophysicalFlowsDocumentation/stable/literated/twodnavierstokes_stochasticforcing_budgets/"/><meta property="twitter:url" content="https://fourierflows.github.io/GeophysicalFlowsDocumentation/stable/literated/twodnavierstokes_stochasticforcing_budgets/"/><link rel="canonical" href="https://fourierflows.github.io/GeophysicalFlowsDocumentation/stable/literated/twodnavierstokes_stochasticforcing_budgets/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GeophysicalFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../../aliasing/">Aliasing</a></li><li><a class="tocitem" href="../../gpu/">GPU</a></li><li><a class="tocitem" href="../../visualize/">Visualize output</a></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox" checked/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">TwoDNavierStokes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../twodnavierstokes_decaying/">2D decaying turbulence</a></li><li><a class="tocitem" href="../twodnavierstokes_stochasticforcing/">2D forced-dissipative turbulence</a></li><li class="is-active"><a class="tocitem" href>2D forced-dissipative turbulence budgets</a><ul class="internal"><li><a class="tocitem" href="#Install-dependencies"><span>Install dependencies</span></a></li><li><a class="tocitem" href="#Let&#39;s-begin"><span>Let&#39;s begin</span></a></li><li><a class="tocitem" href="#Choosing-a-device:-CPU-or-GPU"><span>Choosing a device: CPU or GPU</span></a></li><li><a class="tocitem" href="#Numerical,-domain,-and-simulation-parameters"><span>Numerical, domain, and simulation parameters</span></a></li><li><a class="tocitem" href="#Forcing"><span>Forcing</span></a></li><li><a class="tocitem" href="#Problem-setup"><span>Problem setup</span></a></li><li><a class="tocitem" href="#Setting-initial-conditions"><span>Setting initial conditions</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Time-stepping-the-Problem-forward"><span>Time-stepping the <code>Problem</code> forward</span></a></li><li><a class="tocitem" href="#Plot"><span>Plot</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">SingleLayerQG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../singlelayerqg_betadecay/">Decaying barotropic QG beta-plane turbulence</a></li><li><a class="tocitem" href="../singlelayerqg_betaforced/">Forced-dissipative barotropic QG beta-plane turbulence</a></li><li><a class="tocitem" href="../singlelayerqg_decaying_topography/">Decaying barotropic QG turbulence over topography</a></li><li><a class="tocitem" href="../singlelayerqg_decaying_barotropic_equivalentbarotropic/">SingleLayerQG decaying 2D turbulence with and without finite Rossby radius of deformation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">BarotropicQGQL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../barotropicqgql_betaforced/">Quasi-Linear forced-dissipative barotropic QG beta-plane turbulence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">MultiLayerQG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../multilayerqg_2layer/">Phillips model of Baroclinic Instability</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">SurfaceQG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../surfaceqg_decaying/">Decaying Surface QG turbulence</a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../../modules/twodnavierstokes/">TwoDNavierStokes</a></li><li><a class="tocitem" href="../../modules/singlelayerqg/">SingleLayerQG</a></li><li><a class="tocitem" href="../../modules/barotropicqgql/">BarotropicQGQL</a></li><li><a class="tocitem" href="../../modules/multilayerqg/">MultiLayerQG</a></li><li><a class="tocitem" href="../../modules/surfaceqg/">SurfaceQG</a></li></ul></li><li><a class="tocitem" href="../../stochastic_forcing/">Stochastic forcing</a></li><li><a class="tocitem" href="../../contributing/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/types/">Private types</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">TwoDNavierStokes</a></li><li class="is-active"><a href>2D forced-dissipative turbulence budgets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>2D forced-dissipative turbulence budgets</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FourierFlows/GeophysicalFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FourierFlows/GeophysicalFlows.jl/blob/main/examples/twodnavierstokes_stochasticforcing_budgets.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="twodnavierstokes_stochasticforcing_budgets_example"><a class="docs-heading-anchor" href="#twodnavierstokes_stochasticforcing_budgets_example">2D forced-dissipative turbulence budgets</a><a id="twodnavierstokes_stochasticforcing_budgets_example-1"></a><a class="docs-heading-anchor-permalink" href="#twodnavierstokes_stochasticforcing_budgets_example" title="Permalink"></a></h1><p>A simulation of forced-dissipative two-dimensional turbulence. We solve the two-dimensional vorticity equation with stochastic excitation and dissipation in the form of linear drag and hyperviscosity. As a demonstration, we compute how each of the forcing and dissipation terms contribute to the energy and the enstrophy budgets.</p><h2 id="Install-dependencies"><a class="docs-heading-anchor" href="#Install-dependencies">Install dependencies</a><a id="Install-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Install-dependencies" title="Permalink"></a></h2><p>First let&#39;s make sure we have all required packages installed.</p><pre><code class="language-julia hljs">using Pkg
pkg&quot;add GeophysicalFlows, CUDA, Random, Printf, CairoMakie&quot;</code></pre><h2 id="Let&#39;s-begin"><a class="docs-heading-anchor" href="#Let&#39;s-begin">Let&#39;s begin</a><a id="Let&#39;s-begin-1"></a><a class="docs-heading-anchor-permalink" href="#Let&#39;s-begin" title="Permalink"></a></h2><p>Let&#39;s load <code>GeophysicalFlows.jl</code> and some other packages we need.</p><pre><code class="language-julia hljs">using GeophysicalFlows, CUDA, Random, Printf, CairoMakie

parsevalsum = FourierFlows.parsevalsum
record = CairoMakie.record                # disambiguate between CairoMakie.record and CUDA.record</code></pre><h2 id="Choosing-a-device:-CPU-or-GPU"><a class="docs-heading-anchor" href="#Choosing-a-device:-CPU-or-GPU">Choosing a device: CPU or GPU</a><a id="Choosing-a-device:-CPU-or-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-device:-CPU-or-GPU" title="Permalink"></a></h2><pre><code class="language-julia hljs">dev = CPU()     # Device (CPU/GPU)</code></pre><h2 id="Numerical,-domain,-and-simulation-parameters"><a class="docs-heading-anchor" href="#Numerical,-domain,-and-simulation-parameters">Numerical, domain, and simulation parameters</a><a id="Numerical,-domain,-and-simulation-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical,-domain,-and-simulation-parameters" title="Permalink"></a></h2><p>First, we pick some numerical and physical parameters for our model.</p><pre><code class="language-julia hljs"> n, L  = 256, 2π              # grid resolution and domain length
 ν, nν = 2e-7, 2              # hyperviscosity coefficient and hyperviscosity order
 μ, nμ = 1e-1, 0              # linear drag coefficient
dt, tf = 0.005, 0.2 / μ       # timestep and final time
    nt = round(Int, tf / dt)  # total timesteps
    ns = 4                    # how many intermediate times we want to plot</code></pre><h2 id="Forcing"><a class="docs-heading-anchor" href="#Forcing">Forcing</a><a id="Forcing-1"></a><a class="docs-heading-anchor-permalink" href="#Forcing" title="Permalink"></a></h2><p>We force the vorticity equation with stochastic excitation that is delta-correlated in time and while spatially homogeneously and isotropically correlated. The forcing has a spectrum with power in a ring in wavenumber space of radius <span>$k_f$</span> (<code>forcing_wavenumber</code>) and width <span>$δ_f$</span> (<code>forcing_bandwidth</code>), and it injects energy per unit area and per unit time equal to <span>$\varepsilon$</span>. That is, the forcing covariance spectrum is proportional to <span>$\exp{[-(|\bm{k}| - k_f)^2 / (2 δ_f^2)]}$</span>.</p><pre><code class="language-julia hljs">forcing_wavenumber = 14.0 * 2π/L  # the forcing wavenumber, `k_f`, for a spectrum that is a ring in wavenumber space
forcing_bandwidth  = 1.5  * 2π/L  # the width of the forcing spectrum, `δ_f`
ε = 0.1                           # energy input rate by the forcing

grid = TwoDGrid(dev; nx=n, Lx=L)

K = @. sqrt(grid.Krsq)             # a 2D array with the total wavenumber

forcing_spectrum = @. exp(-(K - forcing_wavenumber)^2 / (2 * forcing_bandwidth^2))
@CUDA.allowscalar forcing_spectrum[grid.Krsq .== 0] .= 0 # ensure forcing has zero domain-average

ε0 = parsevalsum(forcing_spectrum .* grid.invKrsq / 2, grid) / (grid.Lx * grid.Ly)
@. forcing_spectrum *= ε/ε0        # normalize forcing to inject energy at rate ε</code></pre><p>We reset of the random number generator for reproducibility</p><pre><code class="language-julia hljs">if dev==CPU(); Random.seed!(1234); else; CUDA.seed!(1234); end</code></pre><p>Next we construct function <code>calcF!</code> that computes a forcing realization every timestep. First we make sure that if <code>dev=GPU()</code>, then <code>CUDA.rand()</code> function is called for random numbers uniformly distributed between 0 and 1.</p><pre><code class="language-julia hljs">random_uniform = dev==CPU() ? rand : CUDA.rand

function calcF!(Fh, sol, t, clock, vars, params, grid)
  T = eltype(grid)
  @. Fh = sqrt(forcing_spectrum) * cis(2π * random_uniform(T)) / sqrt(clock.dt)

  return nothing
end</code></pre><h2 id="Problem-setup"><a class="docs-heading-anchor" href="#Problem-setup">Problem setup</a><a id="Problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-setup" title="Permalink"></a></h2><p>We initialize a <code>Problem</code> by providing a set of keyword arguments. The <code>stepper</code> keyword defines the time-stepper to be used.</p><pre><code class="language-julia hljs">prob = TwoDNavierStokes.Problem(dev; nx=n, Lx=L, ν, nν, μ, nμ, dt, stepper=&quot;ETDRK4&quot;,
                                calcF=calcF!, stochastic=true)</code></pre><p>Define some shortcuts for convenience.</p><pre><code class="language-julia hljs">sol, clock, vars, params, grid = prob.sol, prob.clock, prob.vars, prob.params, prob.grid

x,  y  = grid.x,  grid.y
Lx, Ly = grid.Lx, grid.Ly</code></pre><p>First let&#39;s see how a forcing realization looks like. Function <code>calcF!()</code> computes the forcing in Fourier space and saves it into variable <code>vars.Fh</code>, so we first need to go back to physical space.</p><p>Note that when plotting, we decorate the variable to be plotted with <code>Array()</code> to make sure it is brought back on the CPU when the variable lives on the GPU.</p><pre><code class="language-julia hljs">calcF!(vars.Fh, sol, 0.0, clock, vars, params, grid)

fig = Figure()

ax = Axis(fig[1, 1],
          xlabel = &quot;x&quot;,
          ylabel = &quot;y&quot;,
          aspect = 1,
          title = &quot;a forcing realization&quot;,
          limits = ((-Lx/2, Lx/2), (-Ly/2, Ly/2)))

heatmap!(ax, x, y, Array(irfft(vars.Fh, grid.nx));
         colormap = :balance, colorrange = (-200, 200))

fig</code></pre><p><img src="../twodnavierstokes_stochasticforcing_budgets-22.png" alt/></p><h2 id="Setting-initial-conditions"><a class="docs-heading-anchor" href="#Setting-initial-conditions">Setting initial conditions</a><a id="Setting-initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-initial-conditions" title="Permalink"></a></h2><p>Our initial condition is a fluid at rest.</p><pre><code class="language-julia hljs">TwoDNavierStokes.set_ζ!(prob, device_array(dev)(zeros(grid.nx, grid.ny)))</code></pre><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><p>Create Diagnostics; the diagnostics are aimed to probe the energy and enstrophy budgets.</p><pre><code class="language-julia hljs">E  = Diagnostic(TwoDNavierStokes.energy,                               prob, nsteps=nt) # energy
Rᵋ = Diagnostic(TwoDNavierStokes.energy_dissipation_hypoviscosity,     prob, nsteps=nt) # energy dissipation by drag μ
Dᵋ = Diagnostic(TwoDNavierStokes.energy_dissipation_hyperviscosity,    prob, nsteps=nt) # energy dissipation by drag μ
Wᵋ = Diagnostic(TwoDNavierStokes.energy_work,                          prob, nsteps=nt) # energy work input by forcing
Z  = Diagnostic(TwoDNavierStokes.enstrophy,                            prob, nsteps=nt) # enstrophy
Rᶻ = Diagnostic(TwoDNavierStokes.enstrophy_dissipation_hypoviscosity,  prob, nsteps=nt) # enstrophy dissipation by drag μ
Dᶻ = Diagnostic(TwoDNavierStokes.enstrophy_dissipation_hyperviscosity, prob, nsteps=nt) # enstrophy dissipation by drag μ
Wᶻ = Diagnostic(TwoDNavierStokes.enstrophy_work,                       prob, nsteps=nt) # enstrophy work input by forcing
diags = [E, Dᵋ, Wᵋ, Rᵋ, Z, Dᶻ, Wᶻ, Rᶻ] # a list of Diagnostics passed to `stepforward!` will  be updated every timestep.</code></pre><h2 id="Time-stepping-the-Problem-forward"><a class="docs-heading-anchor" href="#Time-stepping-the-Problem-forward">Time-stepping the <code>Problem</code> forward</a><a id="Time-stepping-the-Problem-forward-1"></a><a class="docs-heading-anchor-permalink" href="#Time-stepping-the-Problem-forward" title="Permalink"></a></h2><p>We step the <code>Problem</code> forward in time.</p><pre><code class="language-julia hljs">startwalltime = time()
for i = 1:ns
  stepforward!(prob, diags, round(Int, nt/ns))

  TwoDNavierStokes.updatevars!(prob)

  cfl = clock.dt * maximum([maximum(vars.u) / grid.dx, maximum(vars.v) / grid.dy])

  log = @sprintf(&quot;step: %04d, t: %.1f, cfl: %.3f, walltime: %.2f min&quot;, clock.step, clock.t,
        cfl, (time()-startwalltime)/60)

  println(log)
end</code></pre><pre><code class="nohighlight hljs">step: 0100, t: 0.5, cfl: 0.168, walltime: 0.01 min
step: 0200, t: 1.0, cfl: 0.238, walltime: 0.03 min
step: 0300, t: 1.5, cfl: 0.304, walltime: 0.04 min
step: 0400, t: 2.0, cfl: 0.301, walltime: 0.05 min
</code></pre><h2 id="Plot"><a class="docs-heading-anchor" href="#Plot">Plot</a><a id="Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Plot" title="Permalink"></a></h2><p>Now let&#39;s see the final snapshot of the vorticity.</p><pre><code class="language-julia hljs">fig = Figure(resolution = (400, 400))

ax = Axis(fig[1, 1];
          xlabel = &quot;x&quot;,
          ylabel = &quot;y&quot;,
          title = &quot;∇²ψ(x, y, μt=&quot; * @sprintf(&quot;%.2f&quot;, μ * clock.t) * &quot;)&quot;,
          aspect = 1,
          limits = ((-L/2, L/2), (-L/2, L/2)))

heatmap!(ax, x, y, Array(vars.ζ);
         colormap = :viridis, colorrange = (-25, 25))

fig</code></pre><p><img src="../twodnavierstokes_stochasticforcing_budgets-33.png" alt/></p><p>And finally, we plot the evolution of the energy and enstrophy diagnostics and all terms involved in the energy and enstrophy budgets. Last, we also check (by plotting) whether the energy and enstrophy budgets are accurately computed, e.g., <span>$\mathrm{d}E/\mathrm{d}t = W^\varepsilon - R^\varepsilon - D^\varepsilon$</span>.</p><pre><code class="language-julia hljs">sol, clock, vars, params, grid = prob.sol, prob.clock, prob.vars, prob.params, prob.grid

TwoDNavierStokes.updatevars!(prob)

E, Dᵋ, Wᵋ, Rᵋ, Z, Dᶻ, Wᶻ, Rᶻ = diags

clocktime = round(μ * clock.t, digits=2)

dEdt_numerical = (E[2:E.i] - E[1:E.i-1]) / clock.dt # numerical first-order approximation of energy tendency
dZdt_numerical = (Z[2:Z.i] - Z[1:Z.i-1]) / clock.dt # numerical first-order approximation of enstrophy tendency

dEdt_computed = Wᵋ[2:E.i] + Dᵋ[1:E.i-1] + Rᵋ[1:E.i-1]
dZdt_computed = Wᶻ[2:Z.i] + Dᶻ[1:Z.i-1] + Rᶻ[1:Z.i-1]

residual_E = dEdt_computed - dEdt_numerical
residual_Z = dZdt_computed - dZdt_numerical

εᶻ = parsevalsum(forcing_spectrum / 2, grid) / (grid.Lx * grid.Ly)

t = E.t[2:E.i]

fig = Figure(resolution = (800, 1100))

axis_kwargs = (xlabel = &quot;μ t&quot;, )

ax1E = Axis(fig[1, 1]; ylabel = &quot;energy sources/sinks&quot;, axis_kwargs...)
ax2E = Axis(fig[3, 1]; ylabel = &quot;dE/dt&quot;, axis_kwargs...)
ax3E = Axis(fig[5, 1]; axis_kwargs...)

ax1Z = Axis(fig[1, 2]; axis_kwargs...)
ax2Z = Axis(fig[3, 2]; axis_kwargs...)
ax3Z = Axis(fig[5, 2]; axis_kwargs...)

hWᵋ = lines!(ax1E, t, Wᵋ[2:E.i];   linestyle = :solid)
hε  = lines!(ax1E, t, ε .+ 0t;     linestyle = :dash)
hDᵋ = lines!(ax1E, t, Dᵋ[1:E.i-1]; linestyle = :solid)
hRᵋ = lines!(ax1E, t, Rᵋ[1:E.i-1]; linestyle = :solid)

Legend(fig[2, 1],
       [hWᵋ, hε, hDᵋ, hRᵋ],
       [&quot;energy work, Wᵋ&quot;, &quot;ensemble mean energy work, &lt;Wᵋ&gt;&quot;, &quot;dissipation, Dᵋ&quot;, &quot;drag, Rᵋ = - 2μE&quot;])

hc = lines!(ax2E, t, dEdt_computed; linestyle = :solid)
hn = lines!(ax2E, t, dEdt_numerical; linestyle = :dash)

Legend(fig[4, 1],
       [hc, hn],
       [&quot;computed Wᵋ-Dᵋ&quot;, &quot;numerical dE/dt&quot;])

hr = lines!(ax3E, t, residual_E)

Legend(fig[6, 1],
       [hr],
       [&quot;residual&quot;])

hWᶻ = lines!(ax1Z, t, Wᶻ[2:Z.i];  linestyle = :solid)
hεᶻ = lines!(ax1Z, t, εᶻ .+ 0t;    linestyle = :dash)
hDᶻ = lines!(ax1Z, t, Dᶻ[1:Z.i-1]; linestyle = :solid)
hRᶻ = lines!(ax1Z, t, Rᶻ[1:Z.i-1]; linestyle = :solid)

Legend(fig[2, 2],
       [hWᶻ, hεᶻ, hDᶻ, hRᶻ],
       [&quot;enstrophy work, Wᶻ&quot;, &quot;ensemble mean enstophy work, &lt;Wᶻ&gt;&quot;, &quot;dissipation, Dᶻ&quot;, &quot;drag, Rᶻ = - 2μZ&quot;])

hcᶻ = lines!(ax2Z, t, dZdt_computed; linestyle = :solid)
hnᶻ = lines!(ax2Z, t, dZdt_numerical; linestyle = :dash)

Legend(fig[4, 2],
       [hcᶻ, hnᶻ],
       [&quot;computed Wᶻ-Dᶻ&quot;, &quot;numerical dZ/dt&quot;])

hrᶻ = lines!(ax3Z, t, residual_Z)

Legend(fig[6, 2],
       [hr],
       [&quot;residual&quot;])

fig</code></pre><p><img src="../twodnavierstokes_stochasticforcing_budgets-35.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../twodnavierstokes_stochasticforcing/">« 2D forced-dissipative turbulence</a><a class="docs-footer-nextpage" href="../singlelayerqg_betadecay/">Decaying barotropic QG beta-plane turbulence »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 11 December 2023 10:00">Monday 11 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
